В одном терминале запускаем программу ./mapping (mapping.c - исходник), в другом терминале запускаем комманду:
watch -n 1 -d cat /proc/PID/maps, где PID - номер процесса ./mapping ARG, где ARG = 0, 1, 2

Видим появление нового региона с правами rwxp
Расшифровка:
r = Read    - права на чтение (Can be read)
w = Write   - права на запись в память (Can be written)
x = Execute - права на исполнение кода (Can be executed)
p = Private - только в пределах одного процесса (Changes are private)

Что значит Private?

Это означает, что все изменения будут происходить в пределах одного процесса
Как пример, при системном вызове fork() адрессное пространство процесса копируется, копируется и таблица отображения, то есть сразу после вызова fork() все отображенния страниц у программ одинаковые.
НО при попытке изменить данные в любом из процессов срабатывает механизм "copy on write" и отображенная страница копируется в новую физическую страницу (генерируется pagefault, обрабатывается, и т. д.) и потом происходит перевыполнение комманды, вызвавшей изменение отображение и происходится уже запись на новую физическую страницу

Дополнительно:
MAP_ANNONYMOUS:
Анонимные отображения можно представить как обнуленный виртуальный файл. Анонимные отображения - это просто большие, заполненные нулями блоки памяти, готовые к использованию. Эти отображения находятся вне кучи, поэтому не способствуют фрагментации сегмента данных.

MAP_ANONYMOUS + MAP_PRIVATE:

каждый вызов создает отдельное отображение
дети наследуют отображения родителей
записи детей в унаследованные отображения обрабатываются по принципу "копия на запись".
основной целью использования такого отображения является выделение новой обнуленной памяти
malloc использует анонимные частные отображения для обслуживания запросов на выделение памяти размером более MMAP_THRESHOLD байт.
Обычно MMAP_THRESHOLD составляет 128 кБ.
MAP_ANONYMOUS + MAP_SHARED:

каждый вызов создает отдельное отображение, которое не разделяет страницы ни с каким другим отображением.
дети наследуют отображения родителя
нет копирования при записи, когда кто-то другой, имеющий общую связку, пишет на общую связку

PROT_NONE + все права:
Реализация может разрешить доступ, отличный от указанного prot; однако, реализация не должна разрешать успешную запись, если PROT_WRITE не установлен, и не должна разрешать доступ, если установлен только PROT_NONE.  Реализация должна поддерживать, по крайней мере, следующие значения prot: PROT_NONE, PROT_READ, PROT_WRITE и побитовое исключающее OR из PROT_READ и PROT_WRITE.  Дескриптор файла fildes должен быть открыт с разрешением на чтение, независимо от указанных опций защиты. fied. Если указано PROT_WRITE, приложение должно убедиться, что оно открыло дескриптор файла fildes с разрешением на запись, если не указано MAP_PRIVATE


<=========================================> ЧТО ДЕЛАЕТ ПРОГРАММА: <=========================================>
зависит от аргумента argv[1] (варианты: 0, 1, 2)
1) Присоединяет новый регион адресов размером (pagesize * 10) с правами rwxp
2) Изменяет права доступа к региону на r-xp
3) регистрирует обработчик сигнала SIGSEGV
4) Несколько вариантов:
	a. canRead = 1: выдает региону права на только на чтение (r--p), после чего пытается записать в регион что-то. Происходит выше описанная ситуация, что ни при какой реализации нельзя с запрещенным write писать в этот регион. Ловим сегфолт. Выходим из программы, так как иначе после сег фолта произойдет попытка перевыполнить вызвавшую SIGSEGV программу.
	b. canRead = 0: забирает у региона все права (нельзя читать, писать, исполнять), то есть ставим PROT_NONE. После этого пытаемся считать с этого региона. Ловим SIGSEGV. Завершаем программу.
	с. canRead = 2: пропускаем регионы, вызывающие ошибки. Отсоединяем регион посередине. Наблюдаем увеличение количества регионов, так как выделенный нами отсоединился. Отсоединяем последний регион.

<=========================================> ОБРАБОТКА SIGSEGV: <=========================================>
Системный вызов sigaction используется для изменения действий процесса при получении соответствующего сигнала.
Параметр signum задает номер сигнала и может быть равен любому номеру, кроме SIGKILL и SIGSTOP.

Если параметр act не равен нулю, то новое действие, связянное с сигналом signum, устанавливается соответственно act. Если oldact не равен нулю, то предыдущее действие записывается в oldact.

Структура sigaction имеет следующий формат:

struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}
В некоторых архитектурах используется объединение элементов, но не используйте sa_handler и sa_sigaction вместе.

Элемент sa_restorer устарел, поэтому не должен использоваться. POSIX не описывает элемент sa_restorer.

sa_handler задает тип действий процесса, связанный с сигналом signum, и может быть равен: SIG_DFL для выполнения стандартных действий, SIG_IGN для игнорирования сигнала,- или быть указателем на функцию обработки сигнала.

sa_mask задает маску сигналов, которые должны блокироваться при обработке сигнала. Также будет блокироваться и сигнал, вызвавший запуск функции, если только не были использованы флаги SA_NODEFER или SA_NOMASK.

sa_flags содержит набор флагов, которые могут влиять на поведение процесса при обработке сигнала. Он состоит из следующих флагов:

SA_NOCLDSTOP
Если signum равен SIGCHLD, то уведомление об остановке дочернего процесса не будет получено (т.е., в тех случаях, когда дочерний процесс получает сигнал SIGSTOP, SIGTSTP, SIGTTIN или SIGTTOU).
SA_ONESHOT или SA_RESETHAND
Восстановить поведение сигнала после одного вызова обработчика.
SA_ONSTACK
Вызвать обработчик сигнала в дополнительном стеке сигналов, предоставленном sigaltstack(2). Если дополнительный стек недоступен, то будет использован стек по умолчанию.
SA_RESTART
Поведение должно соответствовать семантике сигналов BSD и позволять некоторым системным вызовам работать, в то время как идет обработка сигналов.
SA_NOMASK or SA_NODEFER
Не препятствовать получению сигнала при его обработке.
SA_SIGINFO
Обработчик сигнала требует 3-х аргументов, а не одного. В этом случае надо использовать параметр sa_sigaction вместо sa_handler. (Поле sa_sigaction было добавлено в Linux 2.1.86.)

typedef struct {
    int si_signo;  /* номер сигнала */
    int si_errno;  /* значение <errno.h> при ошибке */
    int si_code;   /* код сигнала; см. текст */
    pid_t si_pid;  /* ID процесса, пославшего сигнал */
    uid_t si_uid;  /* настоящий UID посылающего процесса */
    void *si_addr; /* адрес вызвавшей ошибку инструкции */
    int si_status; /* значение завершения, может включать death-by-signal */
    long si_band;  /* связывающее событие для SIGPOLL/SIGIO */
    union sigval si_value; /* значение сигнала (расширенное) */
} siginfo_t;