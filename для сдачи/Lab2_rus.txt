strace utility

В простейшем случае strace выполняет указанную команду до тех пор, пока она не завершится.  Он перехватывает и записывает системные вызовы, которые
вызываются процессом, и сигналы, которые принимаются процессом.  Имя каждого системного вызова, его аргументы и его повторный‐
       значение поворота выводится по стандартной ошибке или в файл, указанный с параметром -o.

       strace - это полезный инструмент диагностики, обучения и отладки.  Системные администраторы, диагносты и специалисты по устранению неполадок
       сочтут его бесценным для решения проблем с программами, исходный код для которых недоступен, поскольку они не нуждаются
       необходимо перекомпилировать, чтобы отследить их.  Студенты, хакеры и чрезмерно любопытные обнаружат, что многому можно научиться
       о системе и ее системных вызовах путем отслеживания даже обычных программ.  И программисты обнаружат, что, поскольку системные вызовы и
сигналы - это события, которые происходят в интерфейсе пользователя / ядра, тщательное изучение этой границы очень полезно для обнаружения ошибок.‐
       проверка работоспособности и попытка зафиксировать условия гонки.
       
       
       
       
       
execve()
       
       
Системный вызов `execve` - это системный вызов в Unix-подобных операционных системах, который используется для выполнения нового процесса. Он принимает три аргумента: первый аргумент - это путь к исполняемому файлу, второй аргумент - это массив строк, которые представляют аргументы командной строки для нового процесса, и третий аргумент - это массив строк, которые представляют переменные среды для нового процесса.

При вызове `execve` текущий процесс заменяется новым процессом, указанным в исполняемом файле. Новый процесс наследует файловые дескрипторы и сигнальную маску текущего процесса, но все остальные ресурсы (такие как память и ограничения ресурсов) сбрасываются.

`execve` - это системный вызов низкого уровня и обычно используется функциями более высокого уровня, такими как `system`, `popen` и `exec`. Это мощный и универсальный системный вызов, который позволяет программам запускать другие программы с настраиваемыми аргументами и средами.

имя пути должно быть либо двоичным исполняемым файлом, либо скриптом, начинающимся со строки вида:

#!интерпретатор [необязательно-arg]

Подробнее о последнем случае смотрите в разделе "Скрипты интерпретатора" ниже.

argv - это массив указателей на строки, передаваемые новой программе в качестве аргументов командной строки.  По соглашению, первая из
этих строк (т.е. argv[0]) должна содержать имя файла, связанное с выполняемым файлом.  Массив argv должен быть
ограничен нулевым указателем.  (Таким образом, в новой программе argv[argc] будет равен NULL.)

envp - это массив указателей на строки, обычно вида key=value, которые передаются как окружение новой
программы.  Массив envp должен завершаться нулевым указателем.


brk(NULL)

Системный вызов `brk(NULL)` - это системный вызов в Unix-подобных операционных системах, который используется для получения текущего прерывания программы, которое является концом сегмента данных процесса.

Когда вызывается системный вызов `brk(NULL)`, он возвращает текущий разрыв программы, что позволяет программам динамически выделять память, используя системные вызовы `brk` и `sbrk`. Если аргумент, переданный в `brk`, больше, чем текущий перерыв в программе, то перерыв в программе продлевается для выделения запрошенной дополнительной памяти. Если аргумент меньше или равен текущему прерыванию программы, то прерывание программы остается неизменным.

Таким образом, `brk(NULL)` используется для извлечения текущего прерывания программы, которое может быть использовано системными вызовами `brk` и `sbrk` для динамического выделения памяти.

Системный вызов `brk(NULL)` используется для получения текущего прерывания программы, которое является концом сегмента данных процесса. Для сравнения, другие вызовы `brk` используются для выделения дополнительной памяти путем продления перерыва в программе.

Когда вызывается `brk` с аргументом, отличным от NULL, прерывание программы увеличивается для выделения запрошенной дополнительной памяти. Если `brk` вызывается с нулевым аргументом, он извлекает только текущий разрыв программы и не выделяет никакой новой памяти.

Таким образом, основное различие между `brk(NULL)` и другими вызовами `brk` заключается в том, что `brk(NULL)` извлекает только текущий перерыв программы, в то время как другие вызовы `brk` используются для увеличения перерыва программы и выделения дополнительной памяти.







arch_prctl

Системный вызов arch_prctl - это системный вызов, который позволяет процессу контролировать и изменять поведение своей архитектуры. Этот системный вызов специфичен для операционных систем на базе Linux и используется для установки или получения информации о состоянии процесса, зависящей от архитектуры. 

Системный вызов arch_prctl поддерживает набор команд, специфичных для каждой архитектуры. Эти команды могут использоваться для установки или извлечения информации, относящейся к различным аспектам состояния процесса, включая отладку потоков и обработку сигналов. 

В общем, цель системного вызова arch_prctl состоит в том, чтобы позволить процессу изменять свое поведение на основе требований его архитектуры. Это может быть полезно для оптимизации производительности, включения функций, специфичных для конкретной архитектуры, или поддержки инструментов отладки и профилирования процесса.

-arch_prctl() задает состояние процесса или потока, зависящее от архитектуры.  код выбирает подфункцию и передает ей аргумент addr;
-addr интерпретируется либо как unsigned long для операций "set", либо как unsigned long * для операций "get".

mmap

mmap() создает новое сопоставление в виртуальном адресном пространстве вызывающего процесса.  Начальным адресом для нового сопоставления является
       указано в addr.  Аргумент length указывает длину сопоставления (которая должна быть больше 0).

       Если addr равен NULL, то ядро выбирает адрес (выровненный по странице) для создания сопоставления; это наиболее переносимый
       способ создания нового отображения.  Если addr не равен NULL, то ядро воспринимает это как подсказку о том, где разместить отображение; на
       Linux, ядро выберет ближайшую границу страницы (но всегда выше или равной значению, указанному в
/proc/sys/vm/mmap_min_addr) и попытается создать отображение там.  Если там уже существует другое отображение, ядро выбирает
       новый адрес, который может зависеть, а может и не зависеть от подсказки.  Адрес нового сопоставления возвращается в результате вызова.

       Содержимое сопоставления файлов (в отличие от анонимного сопоставления; см. MAP_ANONYMOUS ниже) инициализируется с использованием длины
       байты, начинающиеся со смещения offset в файле (или другом объекте), на который ссылается файловый дескриптор fd.  смещение должно быть кратным
       размера страницы, возвращаемого sysconf(_SC_PAGE_SIZE).

       После возврата вызова mmap() файловый дескриптор fd может быть немедленно закрыт без аннулирования сопоставления.

       Аргумент prot описывает желаемую защиту памяти сопоставления (и не должен конфликтовать с режимом открытия
файла).  Это либо PROT_NONE, либо побитовое значение, либо один или несколько из следующих флагов:

       Могут быть выполнены страницы PROT_EXEC.

       Страницы PROT_READ могут быть прочитаны.

       Страницы PROT_WRITE могут быть записаны.

       Страницы PROT_NONE могут быть недоступны.

   Аргумент flags (флаги)
       Аргумент flags определяет, видны ли обновления сопоставления другим процессам, отображающим ту же область, и
переносятся ли обновления в базовый файл.  Это поведение определяется включением ровно одного из следующих‐
       минимальные значения во флагах:

       MAP_SHARED
              Поделитесь этим отображением.  Обновления сопоставления видны другим процессам, отображающим ту же область, и (в случае
сопоставлений с файловой поддержкой) переносятся в базовый файл.   (Чтобы точно контролировать, когда выполняются обновления
              для перехода к базовому файлу требуется использование msync(2).)

       MAP_SHARED_VALIDATE (начиная с Linux 4.15)
              Этот флаг обеспечивает то же поведение, что и MAP_SHARED, за исключением того, что сопоставления MAP_SHARED игнорируют неизвестные флаги во flags.  Около
              напротив, при создании сопоставления с использованием MAP_SHARED_VALIDATE ядро проверяет, известны ли все переданные флаги, и завершается ошибкой
              отображение с ошибкой EOPNOTSUPP для неизвестных флагов.  Этот тип отображения также необходим для возможности использования некоторой карты‐
              флаги ping (например, MAP_SYNC).

       MAP_PRIVATE
              Создайте частное сопоставление копирования при записи.  Обновления сопоставления не видны другим процессам, отображающим то же самое
              файл, и не переносятся в базовый файл.  Не указано, видны ли изменения, внесенные в файл после
вызова mmap(), в отображенной области.

       Как MAP_SHARED, так и MAP_PRIVATE описаны в POSIX.1-2001 и POSIX.1-2008.  MAP_SHARED_VALIDATE - это расширение для Linux.
       
       
       
Системный вызов mmap() в Linux позволяет процессу отобразить часть своей памяти в файл. Эта операция устанавливает сопоставление между указанным файлом и диапазоном адресов памяти процесса, либо с полной резервной копией, либо с нулевым заполнением. Другими словами, mmap() предоставляет механизм, позволяющий процессам обращаться к файлам так, как если бы они были массивами в памяти. Программист может использовать адрес памяти, возвращаемый mmap(), в качестве указателя на данные файла, которые могут быть считаны или записаны в него, как если бы это была обычная память. Это полезно для различных случаев использования, таких как загрузка больших файлов в память, реализация баз данных с отображением в память и управление общей памятью между процессами.



доступ

access() проверяет, может ли вызывающий процесс получить доступ к пути к файлу.  Если pathname является символической ссылкой, она разыменовывается.

       Режим определяет проверку(ы) доступности, которая должна быть выполнена, и представляет собой либо значение F_OK, либо маску, состоящую из бита‐
       мудрый ИЛИ из одного или нескольких R_OK, W_OK и X_OK.  F_OK проверяет наличие файла.  R_OK, W_OK и X_OK проверяют, является ли
       файл существует и предоставляет разрешения на чтение, запись и выполнение соответственно.

       Проверка выполняется с использованием реальных UID и GID вызывающего процесса, а не эффективных идентификаторов, как это делается при фактической попытке‐
       выполнение операции (например, open(2)) над файлом.  Аналогично, для пользователя root проверка использует набор разрешенных возможностей
       вместо набора эффективных возможностей; и для пользователей, не являющихся пользователями root, проверка использует пустой набор возможностей.

       Это позволяет программам с установленным идентификатором пользователя и программам, наделенным возможностями, легко определять полномочия вызывающего пользователя.  В других
       другими словами, access() не отвечает на вопрос "могу ли я прочитать/записать/выполнить этот файл?" вопрос.  Это отвечает на несколько другой вопрос:
       "(предполагая, что я двоичный файл setuid) может ли пользователь, который вызвал меня, прочитать / записать / выполнить этот файл?", который выдает set-user-ID программ
       возможность предотвратить чтение злоумышленниками файлов, которые пользователи не должны иметь возможности читать.

       Если вызывающий процесс является привилегированным (т.е. его реальный UID равен нулю), то проверка X_OK выполнена успешно для обычного файла, если exe‐
       разрешение cute включено для любого владельца файла, группы или другого лица.
       
       
       системный вызов access() в операционных системах используется для проверки пользовательских разрешений для определенного файла или пути. Он может определить, есть ли у пользователя разрешения на чтение, запись или выполнение, и вернуть результат вызывающей функции. Системный вызов access() полезен для проверки прав пользователя перед выполнением файловой операции, такой как открытие или удаление файла.
       


open()

Системный вызов open() открывает файл, указанный в pathname.  Если указанный файл не существует, он может быть необязательно (если
O_CREAT указан во флагах) создан с помощью open().

       Возвращаемое значение open() - это дескриптор файла, небольшое неотрицательное целое число, которое используется в последующих системных вызовах (read(2),
write(2), lseek(2), fcntl(2) и т.д.) для ссылки на открытый файл.  Файловый дескриптор, возвращаемый успешным вызовом, будет
файловым дескриптором с наименьшим номером, который в данный момент не открыт для процесса.

       По умолчанию для нового файлового дескриптора установлено значение оставаться открытым при выполнении execve(2) (т.е. флаг файлового дескриптора FD_CLOEXEC de‐
       указано в fcntl(2) изначально отключено); флаг O_CLOEXEC, описанный ниже, может быть использован для изменения этого значения по умолчанию.  Файл
       смещение устанавливается в начало файла (см. lseek(2)).

       Вызов функции open() создает новое описание открытого файла, запись в общесистемной таблице открытых файлов.  Описание открытого файла‐
       tion записывает смещение файла и флаги состояния файла (см. ниже).  Дескриптор файла - это ссылка на описание открытого файла‐
       tion; эта ссылка остается неизменной, если впоследствии имя пути будет удалено или изменено для ссылки на другой файл.   Для дальнейшего
       подробные сведения об описаниях открытых файлов см. в ПРИМЕЧАНИЯХ.

       Флаги аргументов должны включать один из следующих режимов доступа: O_RDONLY, O_WRONLY или O_RDWR.  Они запрашивают открытие
файла только для чтения, только для записи или для чтения/записи, соответственно.

       Кроме того, ноль или более флагов создания файла и флагов состояния файла могут быть побитовыми или записываться во флаги.  Флагами создания файла являются
       O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TMPFILE и O_TRUNC.  Флаги состояния файла - это все
остальные флаги, перечисленные ниже.  Различие между этими двумя группами флагов заключается в том, что флаги создания файла влияют на se‐
       мантику самой операции открытия, в то время как флаги состояния файла влияют на семантику последующих операций ввода-вывода.  Файл
       флаги состояния могут быть извлечены и (в некоторых случаях) изменены; подробности см. в fcntl(2).



 openat()
       Системный вызов openat() работает точно так же, как open(), за исключением описанных здесь различий.

       Если путь, указанный в pathname, является относительным, то он интерпретируется относительно каталога, на который ссылается файл de‐
       scriptor dirfd (а не относительно текущего рабочего каталога вызывающего процесса, как это делается open() для относительного‐
       тивное имя пути).

