<====================> ЧТО ДЕЛАЕТ ПРОГРАММА: <====================> 
1) в программе используется глобальная переменная, проининциализированная числом 4
2) при запуске программы инициализируется локальная переменная со значением 15
3) выводится PID, адреса переменных и их значения.
4) Далее используется системный вызов fork().
	fork() — системный вызов в Unix-подобных операционных системах, создающий новый процесс (потомок), который является практически полной копией процесса-родителя, выполняющего этот вызов. 

	После fork() процесс-потомок чаще всего выполняет системный вызов exec(), загружающий в пространство процесса новую программу (именно так, и только так, в Unix-системе выполняется запуск программы в отдельном процессе). Так, первый (нулевой) процесс Unix (ядро системы) создаёт свою копию, чтобы запустить init (процесс с PID = 1), который в свою очередь создаёт дочерние процессы для запуска инициализации системы и терминалов.

	Некоторые программы создают дочерние процессы не для запуска другой программы, а для выполнения параллельной задачи. Так, например, поступают простые сетевые серверы — при подсоединении клиента сервер создаёт свою копию (дочерний процесс), которая обслуживает клиентское соединение и завершается по его закрытии. Родительский же процесс продолжает ожидать новых соединений.

	Вызов fork() выполняется довольно долго, так как требует копирования большого количества данных. Для того чтобы это обойти, некоторые сетевые серверы (например, веб-серверы Apache и Lighttpd) создают дочерние процессы заранее, чтобы уменьшить время отклика сервера. Также существуют «облегчённые» реализации fork() (например, в ядре Linux), отображающие в новый процесс страницы памяти родительского вместо того, чтобы их копировать (новая страница создаётся только при изменении её содержимого одним из процессов), что существенно снижает время создания нового процесса (техника copy-on-write).


5) Проверяется результат вызова fork()
	a. если -1, то ошибка

	b. если 0, то мы в дочернем процессе, и тогда мы печатаем значения переменных, которые были созданы в родительском процессе, и адреса этих переменных. После вывода переменных их значения меняются: глобал: 4 -> 6, а локальная: 15 -> 5. После, измененные переменные выводятся, и программа засыпает на 25 секунд чтобы за ней можно было понаблюдать. После этого осуществляется exit с кодом 5.

	c. если не 0 и не -1, то мы в родительском процессе, а возвращенное нам значение - PID дочернего процесса. Делаем sleep на 3 секунды чтобы дочерний процесс успел поменять значения переменных. Видим, что в родительском процессе изменения не видны. Объяснение - copy on write. Если опять же посмотреть на файл /proc/PID/maps, то увидим, что у стека и у региона глобальных изменяемых переменных стоит флаг p = protected, который как раз и говорит о том что будет с этим регионом. Далее нужно дождаться завершения процесса. Для этого используется int переменная status, указатель на которую передаем в wait. Далее используем несколько макросов для получения информации о завершении работы дочернего процесса. Прежде всего нужно использовать WIFEXITED, который возвращает тру если процесс завершен с помощью exit(code), (_exit(code)), или return из main. После этого используем WEXITSTATUS (который можно использовать только если WIFEXITED вернул true), чтобы получить код ошибки, и хотим по номеру ошибки узнать в чем конкретно проблема. Это все работает если WIFEXITED равно true. А если оно не равно тру? Когда это может быть? Когда процесс прервался сигналом. Для проверки этого используется макрос WIFSIGNALED, и дальше, если макрос вернул тру, то выводим код сигнала с помощью функции WTERMSIG, которую можно использовать только если WIFSIGNALED = true.



Мы видим, что при создании дочернего процесса все регионы копируются, но при этом они отображаются в одну страницу оперативной памяти только если читать данные. Если начать менять, то произойдет переотображение на новую страницу с копированными данными.

Ну и с помощью команды:
ps auxf | ack -B 2 -A 2 ./main
можем наблюдать за тем, что процесс PARENT порожден от zsh, а уже от PARENT порожден CHILD
