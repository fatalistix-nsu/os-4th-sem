Здесь есть две программы: zombie-child и zombie-parent. Начнем по порядку

<==========================> Zombie child <==========================>
1) Печатается PID родителя и делается sleep на 15 секунд для того чтоб мы успели посмотреть ps
2) Далее вызывается fork и проверяется на ошибку. Если ошибки нет, то:
	a. Ребенок выводит свой PID, Parent PID и засыпает на 10 секунд, чтоб опять же отследить поведение процесса. После sleep ребенок печатает что он собирается завершиться и завершается.

	b. Родитель печатает о том что засыпает на 30 секунд. За эти 30 секунд ребенок завершается и становится зомби. Теперь немного о зомби:

Процесс при завершении (как нормальном, так и в результате не обрабатываемого сигнала) освобождает все свои ресурсы и становится «зомби» — пустой записью в таблице процессов, хранящей статус завершения, предназначенный для чтения родительским процессом.

Можно так же посмотреть на maps зомби процесса и увидеть, что он пустой, что говорит о том, что процесс освободил все ресурсы.

Зомби-процесс существует до тех пор, пока родительский процесс не прочитает его статус с помощью системного вызова wait(), в результате чего запись в таблице процессов будет освобождена.

При завершении процесса система уведомляет родительский процесс о завершении дочернего с помощью сигнала SIGCHLD\



Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.

При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удалённую) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор sh должен создать новый процесс), и для восстановления работоспособности (завершения виновной программы) будет необходимо вмешательство системного администратора.

Иногда, если родительский процесс выполняется от имени суперпользователя, для освобождения записей (перезапуска процесса) может потребоваться перезагрузка (причём зачастую — только аппаратным рестартом). Некоторые операционные системы (например, Sun Solaris) при возникновении такой ситуации аварийно завершают часть выполняющихся процессов, восстанавливая работоспособность системы.

Всякий процесс при завершении и до считывания статуса завершения предком пребывает в состоянии зомби, это совершенно нормально и короткоживущие зомби-процессы не представляют проблемы в системе. При этом ряд ошибок программирования может приводить к возникновению и накоплению в системе необрабатываемых процессов-зомби (т. е. уже завершившихся процессов, родитель которых не считывает их статус).

Игнорирование обработки завершения дочерних процессов не является правильным, но обычно не приводит к проблемам для короткоживущих программ, так как при завершении процесса все его потомки становятся потомками процесса init, который постоянно считывает статус своих потомков-зомби, очищая таблицу процессов. Именно для задействования этого механизма выполняется стандартная техника запуска демонов "double fork()": промежуточный родитель завершается, делая родителем своего потомка процесс init .

Для долгоживущих и часто создающих дочерние процессы программ, необходима корректная обработка контроля завершения дочерних программ, потому что накапливание необрабатываемых зомби приводит к «утечке ресурсов» в виде накопления записей в таблице процессов.

В linux, начиная с версии kernel 3.4, процесс имеет возможность объявить себя усыновителем сирот ("subreaper") вместо процесса init командой prctl(PR_SET_CHILD_SUBREAPER)

С помощью утилиты



watch -n 1 -d 'ps auxf | ack -B 2 -A 2 zombie' можно посмотреть за состоянием процессов.




<==========================> РОДИТЕЛЬ ЗОМБИ <==========================>
Теперь про превращение родителя в зомби.
1) Создается программа, печатается PID. 
2) Делается sleep для наблюдений
3) fork() + ошибки
4) Если не ноль, то бесконечный цикл из sleep + printf
5) Если ноль, то то еще один fork() + проверка на ошибки
6) Если ноль в новом форке, то бесконечный цикл printf + sleep на две секунды
7) если не ноль в новом форке, то печатаем PID, PPID, спим на 10 секунд и завершаемся.


ЧТО МЫ НАБЛЮДАЕМ???

Видим с помощью команды 
watch -n 1 -d 'ps auxf | ack -B 2 -A 2 zombie'

что сначала были три процесса в дереве, потом как посередине завершился и стал зомби, то потомок зомби перешел к процессу.....systemd.... 

systemd — подсистема инициализации и управления службами в Linux, фактически вытеснившая в 2010-е годы традиционную подсистему init. Основная особенность — интенсивное распараллеливание запуска служб в процессе загрузки системы, что позволяет существенно ускорить запуск операционной системы.